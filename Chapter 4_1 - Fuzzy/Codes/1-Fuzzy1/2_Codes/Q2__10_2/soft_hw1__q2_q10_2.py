# -*- coding: utf-8 -*-
"""Soft_HW1__Q2_Q10_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17TEWMFckk4Nri59aAyDKaPEuJLXQrv_l

## <div dir=rtl>
<b><p align="justify"><font face = "IRLotus" size = "5">
ترسیم تقریب فازی از تابع اصلی و میزان خطای آن در سوال ۲-۱۰ (تابع تعلق مثلثی)
</font><br />
</div>
"""

import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

alpha = -1
beta = 1
x = np.arange(alpha, beta, 0.001)

h = 0.01
N = 201

g_bar = np.zeros(N)
ej = np.zeros(N)

num = 0
den = 0


def trimf(x, abc):
    return np.fmax(np.fmin((x - abc[0]) / (abc[1] - abc[0]), (abc[2] - x) / (abc[2] - abc[1])), 0)


for j in range(1, N):
    ej[j] = -1 + h * (j - 1)
    if j == 1:
        mu_A_x = trimf(x, [-1, -1, -1 + h])
    elif j == N:
        mu_A_x = trimf(x, [1 - h, 1, 1])
    else:
        mu_A_x = trimf(x, [-1 + h * (j - 2), -1 + h * (j - 1), -1 + h * (j)])

    g_bar[j] = np.sin(ej[j] * np.pi) + np.cos(ej[j] * np.pi) + np.sin(ej[j] * np.pi) * np.cos(ej[j] * np.pi)
    num = num + g_bar[j] * mu_A_x
    den = den + mu_A_x

f_x = num / den
g_x = np.sin(x * np.pi) + np.cos(x * np.pi) + np.sin(x * np.pi) * np.cos(x * np.pi)

plt.figure(0)
plt.plot(x, g_x, 'b-', x, f_x, 'r--', linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$g(x), f(x)$')
plt.legend(['$g(x)$', '$f(x)$'])
plt.grid(True)
plt.savefig('fuzzy1.svg')

plt.figure(1)
plt.plot(x, f_x, linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$f(x)$')
plt.legend(['$f(x)$'])
plt.grid(True)
plt.savefig('fuzzy2.svg')

plt.figure(2)
E = f_x - g_x
plt.plot(x, E, linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$Error$')
plt.legend(['$Error$'])
plt.grid(True)
plt.savefig('fuzzy3.svg')
plt.show()

"""## <div dir=rtl>
<b><p align="justify"><font face = "IRLotus" size = "5">
ترسیم تقریب فازی از تابع اصلی و میزان خطای آن در سوال ۲-۱۰ (تابع تعلق گاوسی)
</font><br />
</div>
"""

import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

alpha = -1
beta = 1
x = np.arange(alpha, beta, 0.001)

h = 0.01
N = 201

g_bar = np.zeros(N)
ej = np.zeros(N)

num = 0
den = 0


def gaussmf(x, abc):
    return np.exp(-1 * ((x - abc[0]) / abc[1]) ** 2)


for j in range(1, N):
    ej[j] = -1 + h * (j - 1)
    if j == 1:
        mu_A_x = gaussmf(x, [-1, h])
    elif j == N:
        mu_A_x = gaussmf(x, [1, h])
    else:
        mu_A_x = gaussmf(x, [-1 + h * (j - 1), h])

    g_bar[j] = np.sin(ej[j] * np.pi) + np.cos(ej[j] * np.pi) + np.sin(ej[j] * np.pi) * np.cos(ej[j] * np.pi)
    num = num + g_bar[j] * mu_A_x
    den = den + mu_A_x
    
f_x = num / den
g_x = np.sin(x * np.pi) + np.cos(x * np.pi) + np.sin(x * np.pi) * np.cos(x * np.pi)

plt.figure(0)
plt.plot(x, g_x, 'b-', x, f_x, 'r--', linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$g(x), f(x)$')
plt.legend(['$g(x)$', '$f(x)$'])
plt.grid(True)
plt.savefig('fuzzy4.svg')

plt.figure(1)
plt.plot(x, f_x, linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$f(x)$')
plt.legend(['$f(x)$'])
plt.grid(True)
plt.savefig('fuzzy5.svg')

plt.figure(2)
E = f_x - g_x
plt.plot(x, E, linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$Error$')
plt.legend(['$Error$'])
plt.grid(True)
plt.savefig('fuzzy6.svg')
plt.show()

"""## <div dir=rtl>
<b><p align="justify"><font face = "IRLotus" size = "5">
ترسیم تقریب فازی از تابع اصلی و میزان خطای آن در سوال ۲-۱۰ (توابع تعلق کم‌تر)
</font><br />
</div>
"""

import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

alpha = -1
beta = 1
x = np.arange(alpha, beta, 0.001)

h = 0.1
N = 41

g_bar = np.zeros(N)
ej = np.zeros(N)

num = 0
den = 0


def trimf(x, abc):
    return np.fmax(np.fmin((x - abc[0]) / (abc[1] - abc[0]), (abc[2] - x) / (abc[2] - abc[1])), 0)


for j in range(1, N):
    ej[j] = -1 + h * (j - 1)
    if j == 1:
        mu_A_x = trimf(x, [-1, -1, -1 + h])
    elif j == N:
        mu_A_x = trimf(x, [1 - h, 1, 1])
    else:
        mu_A_x = trimf(x, [-1 + h * (j - 2), -1 + h * (j - 1), -1 + h * (j)])

    g_bar[j] = np.sin(ej[j] * np.pi) + np.cos(ej[j] * np.pi) + np.sin(ej[j] * np.pi) * np.cos(ej[j] * np.pi)
    num = num + g_bar[j] * mu_A_x
    den = den + mu_A_x

f_x = num / den
g_x = np.sin(x * np.pi) + np.cos(x * np.pi) + np.sin(x * np.pi) * np.cos(x * np.pi)

plt.figure(0)
plt.plot(x, g_x, 'b-', x, f_x, 'r--', linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$g(x), f(x)$')
plt.legend(['$g(x)$', '$f(x)$'])
plt.grid(True)
plt.savefig('fuzzy1.svg')

plt.figure(1)
plt.plot(x, f_x, linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$f(x)$')
plt.legend(['$f(x)$'])
plt.grid(True)
plt.savefig('fuzzy2.svg')

plt.figure(2)
E = f_x - g_x
plt.plot(x, E, linewidth=2)
plt.xlabel('$x$')
plt.ylabel('$Error$')
plt.legend(['$Error$'])
plt.grid(True)
plt.savefig('fuzzy3.svg')
plt.show()

"""## <div dir=rtl>
<b><p align="justify"><font face = "IRLotus" size = "5">
قسمت حل معادلۀ سوال ۲-۱۰
</font><br />
</div>
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve

def f(s):
    return 4*np.sin(s)**2+np.sqrt(2)*np.sin(s)-2
s = np.linspace(-3/4*np.pi, 5/4*np.pi, 100)
root1 = fsolve(f, 1)
root2 = fsolve(f, -1)
print("All roots are:",root1[0], root2[0])
plt.plot(s, f(s))
plt.plot(root1, f(root1), 'ro')
plt.plot(root2, f(root2), 'ro')
plt.grid()
plt.show()

import numpy as np
import sympy as sp
import matplotlib.pyplot as plt

# Define symbolic variables
s = sp.Symbol('s')

# Define symbolic function
f = 4*sp.sin(s)**2+sp.sqrt(2)*sp.sin(s)-2

# Define range for s
s_range = np.linspace(-3/4*np.pi, 5/4*np.pi, 1000)

# Define function for s
f_range = [f.subs(s, s_i) for s_i in s_range]

# Solve for s
s_sol = sp.solve(f, s)

# Print solution
print("All roots are:",s_sol)

# Print solution in degrees
print("All roots are:",[s_i.evalf() for s_i in s_sol])

# plot f for s in range -3/4*np.pi, 5/4*np.pi and mark solution
plt.plot(s_range, f_range)
plt.plot([s_i.evalf() for s_i in s_sol], [f.subs(s, s_i).evalf() for s_i in s_sol], 'ro')
plt.xlabel('s')
plt.ylabel('f(s)')
plt.grid()
plt.show()

#Other Methods
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp

# Define the function
def f(s):
    return 4*sp.sin(s)**2+sp.sqrt(2)*sp.sin(s)-2

# Define the derivative of the function
def df(s):
    return 8*sp.sin(s)*sp.cos(s)+sp.sqrt(2)*sp.cos(s)

# Define the second derivative of the function
def ddf(s):
    return 8*sp.cos(s)**2-8*sp.sin(s)**2+sp.sqrt(2)*sp.sin(s)

# Define the Newton-Raphson method
def newton_raphson(f, df, x0, tol=1e-6, maxiter=100):
    x = x0
    for i in range(maxiter):
        x = x - f(x)/df(x)
        if abs(f(x)) < tol:
            return x
    print("Did not converge")
    return x

# Define the secant method
def secant(f, x0, x1, tol=1e-6, maxiter=100):
    x = x0
    for i in range(maxiter):
        x = x - f(x)*(x-x1)/(f(x)-f(x1))
        if abs(f(x)) < tol:
            return x
    print("Did not converge")
    return x

# Define the bisection method
def bisection(f, a, b, tol=1e-6, maxiter=100):
    for i in range(maxiter):
        x = (a+b)/2
        if abs(f(x)) < tol:
            return x
        if f(a)*f(x) < 0:
            b = x
        else:
            a = x
    print("Did not converge")
    return x

# Define the Newton-Raphson method with second derivative
def newton_raphson2(f, df, ddf, x0, tol=1e-6, maxiter=100):
    x = x0
    for i in range(maxiter):
        x = x - f(x)*df(x)/(df(x)**2-f(x)*ddf(x))
        if abs(f(x)) < tol:
            return x
    print("Did not converge")
    return x

# Define the secant method with second derivative
def secant2(f, x0, x1, tol=1e-6, maxiter=100):
    x = x0
    for i in range(maxiter):
        x = x - f(x)*(x-x1)/(f(x)-f(x1))
        if abs(f(x)) < tol:
            return x
    print("Did not converge")
    return x

# Define the bisection method with second derivative
def bisection2(f, a, b, tol=1e-6, maxiter=100):
    for i in range(maxiter):
        x = (a+b)/2
        if abs(f(x)) < tol:
            return x
        if f(a)*f(x) < 0:
            b = x
        else:
            a = x
    print("Did not converge")
    return x