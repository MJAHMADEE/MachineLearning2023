# -*- coding: utf-8 -*-
"""AI4021 - Chapter 3 - Hopfield and Hamming.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d9LzsQLMorQK8rZsfQXID62uRtefpKIz
"""

!pip install --upgrade --no-cache-dir gdown
!gdown 1QTi7dJtNAfFR5mG0rd8K3ZGvEIfSn_DS
!unzip PersianData.zip

from PIL import Image, ImageDraw
import random

def convertImageToBinary(path):
    """
    Convert an image to a binary representation based on pixel intensity.

    Args:
        path (str): The file path to the input image.

    Returns:
        list: A binary representation of the image where white is represented by -1 and black is represented by 1.
    """
    # Open the image file.
    image = Image.open(path)

    # Create a drawing tool for manipulating the image.
    draw = ImageDraw.Draw(image)

    # Determine the image's width and height in pixels.
    width = image.size[0]
    height = image.size[1]

    # Load pixel values for the image.
    pix = image.load()

    # Define a factor for intensity thresholding.
    factor = 100

    # Initialize an empty list to store the binary representation.
    binary_representation = []

    # Loop through all pixels in the image.
    for i in range(width):
        for j in range(height):
            # Extract the Red, Green, and Blue (RGB) values of the pixel.
            red = pix[i, j][0]
            green = pix[i, j][1]
            blue = pix[i, j][2]

            # Calculate the total intensity of the pixel.
            total_intensity = red + green + blue

            # Determine whether the pixel should be white or black based on the intensity.
            if total_intensity > (((255 + factor) // 2) * 3):
                red, green, blue = 255, 255, 255  # White pixel
                binary_representation.append(-1)
            else:
                red, green, blue = 0, 0, 0  # Black pixel
                binary_representation.append(1)

            # Set the pixel color accordingly.
            draw.point((i, j), (red, green, blue))

    # Clean up the drawing tool.
    del draw

    # Return the binary representation of the image.
    return binary_representation

from PIL import Image, ImageDraw
import random

def generateNoisyImages():
    # List of image file paths
    image_paths = [
        "/content/1.jpg",
        "/content/2.jpg",
        "/content/3.jpg",
        "/content/4.jpg",
        "/content/5.jpg"
    ]

    for i, image_path in enumerate(image_paths, start=1):
        noisy_image_path = f"/content/noisy{i}.jpg"
        getNoisyBinaryImage(image_path, noisy_image_path)
        print(f"Noisy image for {image_path} generated and saved as {noisy_image_path}")

def getNoisyBinaryImage(input_path, output_path):
    """
    Add noise to an image and save it as a new file.

    Args:
        input_path (str): The file path to the input image.
        output_path (str): The file path to save the noisy image.
    """
    # Open the input image.
    image = Image.open(input_path)

    # Create a drawing tool for manipulating the image.
    draw = ImageDraw.Draw(image)

    # Determine the image's width and height in pixels.
    width = image.size[0]
    height = image.size[1]

    # Load pixel values for the image.
    pix = image.load()

    # Define a factor for introducing noise.
    noise_factor = 100

    # Loop through all pixels in the image.
    for i in range(width):
        for j in range(height):
            # Generate a random noise value within the specified factor.
            rand = random.randint(-noise_factor, noise_factor)

            # Add the noise to the Red, Green, and Blue (RGB) values of the pixel.
            red = pix[i, j][0] + rand
            green = pix[i, j][1] + rand
            blue = pix[i, j][2] + rand

            # Ensure that RGB values stay within the valid range (0-255).
            if red < 0:
                red = 0
            if green < 0:
                green = 0
            if blue < 0:
                blue = 0
            if red > 255:
                red = 255
            if green > 255:
                green = 255
            if blue > 255:
                blue = 255

            # Set the pixel color accordingly.
            draw.point((i, j), (red, green, blue))

    # Save the noisy image as a file.
    image.save(output_path, "JPEG")

    # Clean up the drawing tool.
    del draw

# Generate noisy images and save them
generateNoisyImages()

# from PIL import Image, ImageDraw
# import random

# def generateNoisyImages():
#     # List of image file paths
#     image_paths = [
#         "/content/1.jpg",
#         "/content/2.jpg",
#         "/content/3.jpg",
#         "/content/4.jpg",
#         "/content/5.jpg"
#     ]

#     for i, image_path in enumerate(image_paths, start=1):
#         noisy_image_path = f"/content/noisy{i}.jpg"
#         getNoisyBinaryImage(image_path, noisy_image_path)
#         print(f"Noisy image for {image_path} generated and saved as {noisy_image_path}")

# def getNoisyBinaryImage(input_path, output_path):
#     """
#     Add noise and modify black points to white in an image and save it as a new file.

#     Args:
#         input_path (str): The file path to the input image.
#         output_path (str): The file path to save the noisy image.
#     """
#     # Open the input image.
#     image = Image.open(input_path)

#     # Create a drawing tool for manipulating the image.
#     draw = ImageDraw.Draw(image)

#     # Determine the image's width and height in pixels.
#     width = image.size[0]
#     height = image.size[1]

#     # Load pixel values for the image.
#     pix = image.load()

#     # Define a factor for introducing noise.
#     noise_factor = 1

#     # Loop through all pixels in the image.
#     for i in range(width):
#         for j in range(height):
#             # Generate a random noise value within the specified factor.
#             rand = random.randint(-noise_factor, noise_factor)

#             # Add the noise to the Red, Green, and Blue (RGB) values of the pixel.
#             red = pix[i, j][0] + rand
#             green = pix[i, j][1] + rand
#             blue = pix[i, j][2] + rand

#             # Ensure that RGB values stay within the valid range (0-255).
#             if red < 0:
#                 red = 0
#             if green < 0:
#                 green = 0
#             if blue < 0:
#                 blue = 0
#             if red > 255:
#                 red = 255
#             if green > 255:
#                 green = 255
#             if blue > 255:
#                 blue = 255

#             # Modify black points to white (you can adjust the threshold)
#             if red < 50 and green < 50 and blue < 50:
#                 red = 255
#                 green = 255
#                 blue = 255

#             # Set the pixel color accordingly.
#             draw.point((i, j), (red, green, blue))

#     # Save the noisy image as a file.
#     image.save(output_path, "JPEG")

#     # Clean up the drawing tool.
#     del draw

# # Generate noisy images and save them
# generateNoisyImages()

from PIL import Image, ImageDraw
import random

def getNoisyBinaryImage(input_path, output_path, num_missing_points, conversion_percentage):
    """
    Add noise to an image, generate missing points, and save it as a new file.

    Args:
        input_path (str): The file path to the input image.
        output_path (str): The file path to save the noisy image.
        num_missing_points (int): The number of missing points to generate.
        conversion_percentage (float): The percentage of black pixels to convert to white.
    """
    # Open the input image.
    image = Image.open(input_path)

    # Create a drawing tool for manipulating the image.
    draw = ImageDraw.Draw(image)

    # Determine the image's width and height in pixels.
    width = image.size[0]
    height = image.size[1]

    # Load pixel values for the image.
    pix = image.load()

    # Define a factor for introducing noise.
    noise_factor = 5

    # Loop through all pixels in the image.
    for i in range(width):
        for j in range(height):
            # Generate a random noise value within the specified factor.
            rand = random.randint(-noise_factor, noise_factor)

            # Add the noise to the Red, Green, and Blue (RGB) values of the pixel.
            red = pix[i, j][0] + rand
            green = pix[i, j][1] + rand
            blue = pix[i, j][2] + rand

            # Ensure that RGB values stay within the valid range (0-255).
            if red < 0:
                red = 0
            if green < 0:
                green = 0
            if blue < 0:
                blue = 0
            if red > 255:
                red = 255
            if green > 255:
                green = 255
            if blue > 255:
                blue = 255

            # Convert some black pixels to white based on the conversion percentage.
            if (red, green, blue) == (0, 0, 0) and random.random() < conversion_percentage:
                red, green, blue = 255, 255, 255

            # Set the pixel color accordingly.
            draw.point((i, j), (red, green, blue))

    # Generate missing points in the image.
    for _ in range(num_missing_points):
        x = random.randint(0, width - 1)
        y = random.randint(0, height - 1)
        draw.point((x, y), (255, 255, 255))  # Set the missing point to white

    # Save the noisy image as a file.
    image.save(output_path, "JPEG")

    # Clean up the drawing tool.
    del draw

from PIL import Image, ImageDraw
import random

def generateNoisyImages():
    # List of image file paths
    image_paths = [
        "/content/1.jpg",
        "/content/2.jpg",
        "/content/3.jpg",
        "/content/4.jpg",
        "/content/5.jpg"
    ]

    for i, image_path in enumerate(image_paths, start=1):
        noisy_image_path = f"/content/noisy{i}.jpg"
        # Specify the number of missing points and conversion percentage here
        getNoisyBinaryImage(image_path, noisy_image_path, num_missing_points=500, conversion_percentage=0.1)
        print(f"Noisy image for {image_path} generated and saved as {noisy_image_path}")

# Generate noisy images with missing points and black-to-white conversion
generateNoisyImages()

from pylab import *
from math import sqrt
import matplotlib.pyplot as plt
import os

# Define the path to the input image
IMAGE_PATH = "/content/noisy5.jpg"

def show(matrix):
    """
    Display a matrix in a formatted manner.

    Args:
        matrix (list of lists): The matrix to be displayed.
    """
    for j in range(len(matrix)):
        for i in range(len(matrix[0])):
            print("{:3f}".format(matrix[j][i]), end=" ")
        print(sep="")

def change(vector, a, b):
    """
    Transform a vector into a matrix of specified dimensions.

    Args:
        vector (list): The vector to be transformed.
        a (int): The number of columns in the resulting matrix.
        b (int): The number of rows in the resulting matrix.

    Returns:
        list of lists: The transformed matrix.
    """
    matrix = [[0 for j in range(a)] for i in range(b)]
    k = 0
    j = 0
    while k < b:
        i = 0
        while i < a:
            matrix[k][i] = vector[j]
            j += 1
            i += 1
        k += 1
    return matrix

def product(matrix, vector, T):
    """
    Multiply a matrix by a vector.

    Args:
        matrix (list of lists): The matrix to be multiplied.
        vector (list): The vector to be multiplied.
        T (float): The threshold parameter for the activation function.

    Returns:
        list: The resulting vector after multiplication.
    """
    result_vector = []
    for i in range(len(matrix)):
        x = 0
        for j in range(len(vector)):
            x = x + matrix[i][j] * vector[j]
        result_vector.append((x + T))
    return result_vector

def action(vector, T, Emax):
    """
    Activation function to process a vector.

    Args:
        vector (list): The input vector to be processed.
        T (float): The threshold parameter for the activation function.
        Emax (float): The maximum allowable value for the difference in output vectors between consecutive iterations.

    Returns:
        list: The output vector after activation.
    """
    result_vector = []
    for value in vector:
        if value <= 0:
            result_vector.append(0)
        elif 0 < value <= T:
            result_vector.append(Emax * value)
        elif value > T:
            result_vector.append(T)
    return result_vector

def mysum(vector, j):
    """
    Calculate the sum of vector values excluding the element at index j.

    Args:
        vector (list): The input vector.
        j (int): The index of the element to be excluded from the sum.

    Returns:
        float: The sum of vector values with the element at index j excluded.
    """
    p = 0
    total_sum = 0
    while p < len(vector):
        if p != j:
            total_sum = total_sum + vector[p]
        p += 1
    return total_sum

def norm(vector, p):
    """
    Calculate the difference between two vectors and compute the norm of the resulting vector.

    Args:
        vector (list): The first vector.
        p (list): The second vector for subtraction.

    Returns:
        float: The Euclidean norm of the difference between the two vectors.
    """
    difference = []
    for i in range(len(vector)):
        difference.append(vector[i] - p[i])
    sum = 0
    for element in difference:
        sum += element * element
    return sqrt(sum)

# List of paths to example images
path = [
    '/content/1.jpg',
    '/content/2.jpg',
    '/content/3.jpg',
    '/content/4.jpg',
    '/content/5.jpg',
]

x = []  # Binary representations of example images
print(os.path.basename(IMAGE_PATH))

# Convert and store binary representations of example images
for i in path:
    x.append(convertImageToBinary(i))

y = convertImageToBinary(IMAGE_PATH)  # Binary representation of the input image
entr = y
k = len(x)  # Number of example images
a = 96  # Number of columns in the transformed matrix
b = 96  # Number of rows in the transformed matrix
entr = y
q = change(y, a, b)  # Transformation of input image into a matrix
plt.matshow(q)
plt.colorbar()

m = len(x[0])
w = [[(x[i][j]) / 2 for j in range(m)] for i in range(k)]  # Weight matrix
T = m / 2  # Activation function threshold parameter
e = round(1 / len(x), 1)
E = [[0 for j in range(k)] for i in range(k)]  # Synaptic connection matrix
Emax = 0.000001  # Maximum allowable difference norm between output vectors in consecutive iterations
U = 1 / Emax

# Set values for the synaptic connection matrix
for i in range(k):
    for j in range(k):
        if j == i:
            E[i][j] = 1.0
        else:
            E[i][j] = -e

s = [product(w, y, T)]  # Initial output vector
p = action(s[0], U, Emax)
y = [p]
i = 0
j = []
p = [0 for j in range(len(s[0]))]

# Iterate until the difference norm is less than Emax
while norm(y[i], p) >= Emax:
    s.append([0 for j in range(len(s[0]))])
    for j in range(len(s[0])):
        s[i + 1][j] = y[i][j] - e * mysum(y[i], j)
    y.append((action(s[i + 1], U, Emax)))
    i += 1
    p = y[i - 1]

print('Output Vectors Table:')
show(y)
print('Last Output Vector:', *y[len(y) - 1])

# Determine the class with the highest output value
result_index = y[len(y) - 1].index(max(y[len(y) - 1])) + 1

if max(y[len(y) - 1]) == 0:
    print("The Hamming network cannot make a preference between classes.")
    print("In the case of a small number of input characteristics, the network may not be able to classify the image.")
    plt.show()
    exit()
else:
    q = change(x[result_index - 1], a, b)
    print('The highest positive output value is associated with class', result_index)
    plt.matshow(q)
    plt.colorbar()
    plt.show()

from pylab import *
from math import sqrt
import matplotlib.pyplot as plt
import os

# Define the path to the input image
IMAGE_PATH = "/content/noisy5.jpg"

def show(matrix):
    """
    Display a matrix in a formatted manner.

    Args:
        matrix (list of lists): The matrix to be displayed.
    """
    for j in range(len(matrix)):
        for i in range(len(matrix[0])):
            print("{:.3f}".format(matrix[j][i]), end=" ")
        print(sep="")

def change(vector, a, b):
    """
    Transform a vector into a matrix of specified dimensions.

    Args:
        vector (list): The vector to be transformed.
        a (int): The number of columns in the resulting matrix.
        b (int): The number of rows in the resulting matrix.

    Returns:
        list of lists: The transformed matrix.
    """
    matrix = [[0 for j in range(a)] for i in range(b)]
    k = 0
    j = 0
    while k < b:
        i = 0
        while i < a:
            matrix[k][i] = vector[j]
            j += 1
            i += 1
        k += 1
    return matrix

def product(matrix, vector, T):
    """
    Multiply a matrix by a vector.

    Args:
        matrix (list of lists): The matrix to be multiplied.
        vector (list): The vector to be multiplied.
        T (float): The threshold parameter for the activation function.

    Returns:
        list: The resulting vector after multiplication.
    """
    result_vector = []
    for i in range(len(matrix)):
        x = 0
        for j in range(len(vector)):
            x = x + matrix[i][j] * vector[j]
        result_vector.append((x + T))
    return result_vector

def action(vector, T, Emax):
    """
    Activation function to process a vector.

    Args:
        vector (list): The input vector to be processed.
        T (float): The threshold parameter for the activation function.
        Emax (float): The maximum allowable value for the difference in output vectors between consecutive iterations.

    Returns:
        list: The output vector after activation.
    """
    result_vector = []
    for value in vector:
        if value <= 0:
            result_vector.append(0)
        elif 0 < value <= T:
            result_vector.append(Emax * value)
        elif value > T:
            result_vector.append(T)
    return result_vector

def mysum(vector, j):
    """
    Calculate the sum of vector values excluding the element at index j.

    Args:
        vector (list): The input vector.
        j (int): The index of the element to be excluded from the sum.

    Returns:
        float: The sum of vector values with the element at index j excluded.
    """
    p = 0
    total_sum = 0
    while p < len(vector):
        if p != j:
            total_sum = total_sum + vector[p]
        p += 1
    return total_sum

def norm(vector, p):
    """
    Calculate the difference between two vectors and compute the norm of the resulting vector.

    Args:
        vector (list): The first vector.
        p (list): The second vector for subtraction.

    Returns:
        float: The Euclidean norm of the difference between the two vectors.
    """
    difference = []
    for i in range(len(vector)):
        difference.append(vector[i] - p[i])
    sum = 0
    for element in difference:
        sum += element * element
    return sqrt(sum)

# List of paths to example images
path = [
    '/content/1.jpg',
    '/content/2.jpg',
    '/content/3.jpg',
    '/content/4.jpg',
    '/content/5.jpg',
]

x = []  # Binary representations of example images
print(os.path.basename(IMAGE_PATH))

# Convert and store binary representations of example images
for i in path:
    x.append(convertImageToBinary(i))

y = convertImageToBinary(IMAGE_PATH)  # Binary representation of the input image
entr = y
k = len(x)  # Number of example images
a = 96  # Number of columns in the transformed matrix
b = 96  # Number of rows in the transformed matrix
entr = y
q = change(y, a, b)  # Transformation of the input image into a matrix
plt.matshow(q)
plt.colorbar()

m = len(x[0])
w = [[(x[i][j]) / 2 for j in range(m)] for i in range(k)]  # Weight matrix
T = m / 2  # Activation function threshold parameter
e = round(1 / len(x), 1)
E = [[0 for j in range(k)] for i in range(k)]  # Synaptic connection matrix
Emax = 0.000001  # Maximum allowable difference norm between output vectors in consecutive iterations
U = 1 / Emax

# Set values for the synaptic connection matrix
for i in range(k):
    for j in range(k):
        if j == i:
            E[i][j] = 1.0
        else:
            E[i][j] = -e

s = [product(w, y, T)]  # Initial output vector
p = action(s[0], U, Emax)
y = [p]
i = 0
j = []
p = [0 for j in range(len(s[0]))]

# Iterate until the difference norm is less than Emax
while norm(y[i], p) >= Emax:
    s.append([0 for j in range(len(s[0]))])
    for j in range(len(s[0])):
        s[i + 1][j] = y[i][j] - e * mysum(y[i], j)
    y.append((action(s[i + 1], U, Emax)))
    i += 1
    p = y[i - 1]

print('Output Vectors Table:')
for idx, output_vector in enumerate(y):
    print(f'Iteration {idx + 1}:', *output_vector)
    print('Weights (x, y):')
    for j in range(len(x[0])):
        print(f'x{j}: {w[0][j]:.3f}, y{j}: {w[1][j]:.3f}')
    print()

print('Last Output Vector:', *y[len(y) - 1])

# Determine the class with the highest output value
result_index = y[len(y) - 1].index(max(y[len(y) - 1])) + 1

if max(y[len(y) - 1]) == 0:
    print("The Hamming network cannot make a preference between classes.")
    print("In the case of a small number of input characteristics, the network may not be able to classify the image.")
    plt.show()
    exit()
else:
    q = change(x[result_index - 1], a, b)
    print('The highest positive output value is associated with class', result_index)
    plt.matshow(q)
    plt.colorbar()
    plt.show()

len(x)

from pylab import *
from math import sqrt
import matplotlib.pyplot as plt
import os

# Define the path to the input image
IMAGE_PATH = "/content/noisy5.jpg"

def show(matrix):
    """
    Display a matrix in a formatted manner.

    Args:
        matrix (list of lists): The matrix to be displayed.
    """
    for j in range(len(matrix)):
        for i in range(len(matrix[0])):
            print("{:.3f}".format(matrix[j][i]), end=" ")
        print(sep="")

def change(vector, a, b):
    """
    Transform a vector into a matrix of specified dimensions.

    Args:
        vector (list): The vector to be transformed.
        a (int): The number of columns in the resulting matrix.
        b (int): The number of rows in the resulting matrix.

    Returns:
        list of lists: The transformed matrix.
    """
    matrix = [[0 for j in range(a)] for i in range(b)]
    k = 0
    j = 0
    while k < b:
        i = 0
        while i < a:
            matrix[k][i] = vector[j]
            j += 1
            i += 1
        k += 1
    return matrix

def product(matrix, vector, T):
    """
    Multiply a matrix by a vector.

    Args:
        matrix (list of lists): The matrix to be multiplied.
        vector (list): The vector to be multiplied.
        T (float): The threshold parameter for the activation function.

    Returns:
        list: The resulting vector after multiplication.
    """
    result_vector = []
    for i in range(len(matrix)):
        x = 0
        for j in range(len(vector)):
            x = x + matrix[i][j] * vector[j]
        result_vector.append((x + T))
    return result_vector

def action(vector, T, Emax):
    """
    Activation function to process a vector.

    Args:
        vector (list): The input vector to be processed.
        T (float): The threshold parameter for the activation function.
        Emax (float): The maximum allowable value for the difference in output vectors between consecutive iterations.

    Returns:
        list: The output vector after activation.
    """
    result_vector = []
    for value in vector:
        if value <= 0:
            result_vector.append(0)
        elif 0 < value <= T:
            result_vector.append(Emax * value)
        elif value > T:
            result_vector.append(T)
    return result_vector

def mysum(vector, j):
    """
    Calculate the sum of vector values excluding the element at index j.

    Args:
        vector (list): The input vector.
        j (int): The index of the element to be excluded from the sum.

    Returns:
        float: The sum of vector values with the element at index j excluded.
    """
    p = 0
    total_sum = 0
    while p < len(vector):
        if p != j:
            total_sum = total_sum + vector[p]
        p += 1
    return total_sum

def norm(vector, p):
    """
    Calculate the difference between two vectors and compute the norm of the resulting vector.

    Args:
        vector (list): The first vector.
        p (list): The second vector for subtraction.

    Returns:
        float: The Euclidean norm of the difference between the two vectors.
    """
    difference = []
    for i in range(len(vector)):
        difference.append(vector[i] - p[i])
    sum = 0
    for element in difference:
        sum += element * element
    return sqrt(sum)

# List of paths to example images
path = [
    '/content/1.jpg',
    '/content/2.jpg',
    '/content/3.jpg',
    '/content/4.jpg',
    '/content/5.jpg',
]

x = []  # Binary representations of example images
print(os.path.basename(IMAGE_PATH))

# Convert and store binary representations of example images
for i in path:
    x.append(convertImageToBinary(i))

y = convertImageToBinary(IMAGE_PATH)  # Binary representation of the input image
entr = y
k = len(x)  # Number of example images
a = 96  # Number of columns in the transformed matrix
b = 96  # Number of rows in the transformed matrix
entr = y
q = change(y, a, b)  # Transformation of the input image into a matrix
plt.matshow(q)
plt.colorbar()

m = len(x[0])
w = [[(x[i][j]) / 2 for j in range(m)] for i in range(k)]  # Weight matrix
T = m / 2  # Activation function threshold parameter
e = round(1 / len(x), 1)
E = [[0 for j in range(k)] for i in range(k)]  # Synaptic connection matrix
Emax = 0.000001  # Maximum allowable difference norm between output vectors in consecutive iterations
U = 1 / Emax

# Set values for the synaptic connection matrix
for i in range(k):
    for j in range(k):
        if j == i:
            E[i][j] = 1.0
        else:
            E[i][j] = -e

s = [product(w, y, T)]  # Initial output vector
p = action(s[0], U, Emax)
y = [p]
i = 0
j = []
p = [0 for j in range(len(s[0]))]

# Iterate until the difference norm is less than Emax
while norm(y[i], p) >= Emax:
    s.append([0 for j in range(len(s[0]))])
    for j in range(len(s[0])):
        s[i + 1][j] = y[i][j] - e * mysum(y[i], j)
    y.append((action(s[i + 1], U, Emax)))
    i += 1
    p = y[i - 1]

print('Output Vectors Table:')
for idx, output_vector in enumerate(y):
    print(f'Iteration {idx + 1}:', *output_vector)
    print('Weights (x, y):')
    for j in range(len(x[0])):
        print(f'x{j}: {w[0][j]:.3f}, y{j}: {w[1][j]:.3f}')
    print('Error:', norm(y[idx], p))
    print()

print('Last Output Vector:', *y[len(y) - 1])

# Determine the class with the highest output value
result_index = y[len(y) - 1].index(max(y[len(y) - 1])) + 1

if max(y[len(y) - 1]) == 0:
    print("The Hamming network cannot make a preference between classes.")
    print("In the case of a small number of input characteristics, the network may not be able to classify the image.")
    plt.show()
    exit()
else:
    q = change(x[result_index - 1], a, b)
    print('The highest positive output value is associated with class', result_index)
    plt.matshow(q)
    plt.colorbar()
    plt.show()

from PIL import Image

# Open the image
image_path = "/content/Neural-networks/Hamming Neural Network/examples of numbers/2.jpg"
image = Image.open(image_path)

# Get the shape (dimensions) and number of columns (width) of the image
image_shape = image.size
image_width = image_shape[0]

print("Image Shape (Dimensions):", image_shape)
print("Number of Columns (Width):", image_width)

!git clone https://github.com/fomin-max/Neural-networks.git

from PIL import Image, ImageDraw  # Подключим необходимые библиотеки.
import random

def convertImageToBinary(path):
    image = Image.open(path)  # Открываем изображение.
    draw = ImageDraw.Draw(image)  # Создаем инструмент для рисования.
    width = image.size[0]  # Определяем ширину.
    height = image.size[1]  # Определяем высоту.
    pix = image.load()  # Выгружаем значения пикселей.
    factor = 100
    t = []
    for i in range(width):
        for j in range(height):
            a = pix[i, j][0]
            b = pix[i, j][1]
            c = pix[i, j][2]
            S = a + b + c
            if int(S > (((255 + factor) // 2) * 3)):
                a, b, c = 255, 255, 255
                t.append(-1)
            else:
                a, b, c = 0, 0, 0
                t.append(1)
            draw.point((i, j), (a, b, c))
    del draw
    return t

# Функция для зашумления образа
def getNoisyBinaryImage(path):
    image = Image.open(path)  # Открываем изображение.
    draw = ImageDraw.Draw(image)  # Создаем инструмент для рисования.
    width = image.size[0]  # Определяем ширину.
    height = image.size[1]  # Определяем высоту.
    pix = image.load()  # Выгружаем значения пикселей.
    factor = 350
    t = []
    for i in range(width):
        for j in range(height):
            rand = random.randint(-factor, factor)
            a = pix[i, j][0] + rand
            b = pix[i, j][1] + rand
            c = pix[i, j][2] + rand
            if (a < 0):
                a = 0
            if (b < 0):
                b = 0
            if (c < 0):
                c = 0
            if (a > 255):
                a = 255
            if (b > 255):
                b = 255
            if (c > 255):
                c = 255
            draw.point((i, j), (a, b, c))
    image.save("examples of numbers/noisy5.jpg", "JPEG")
    del draw
    return t

from pylab import *
from math import sqrt
import matplotlib.pyplot as plt
# import convertImage as convertModule
import os

IMAGE_PATH = "/content/Neural-networks/Hamming Neural Network/test numbers/noisy4.jpg"

def show(s):  # функция для красивого отображения матриц
    for j in range(len(s)):
        for i in range(len(s[0])):
            print("{:3f}".format(s[j][i]), end=" ")
        print(sep="")


def change(v, a, b):  # функция для преобразования вектора v в матрицу заданных размеров a и b
    t = [[0 for j in range(a)] for i in range(b)]
    k = 0
    j = 0
    while k < b:
        i = 0
        while i < a:
            t[k][i] = v[j]
            j += 1
            i += 1
        k += 1
    return t


def product(w, y, T):  # функция умножения матрицы на вектор
    z = []
    for i in range(len(w)):
        x = 0
        for j in range(len(y)):
            x = x + w[i][j] * y[j]
        z.append((x + T))
    return z


def action(s, T, Emax):  # активационная функция
    t = []
    for i in s:
        if i <= 0:
            t.append(0)
        elif 0 < i <= T:
            t.append(Emax * i)
        elif i > T:
            t.append(T)
    return t


def mysum(y, j):  # функция для вычисления суммы значений вектора при  i != j
    p = 0
    sum = 0
    while p < len(y):
        if p != j:
            sum = sum + y[p]
        p += 1
    return sum


def norm(v, p):  # функция вычисляющая разность двух векторов и вычисляющая норму получившегося вектора
    t = []
    for i in range(len(v)):
        t.append(v[i] - p[i])
    sum = 0
    for i in t:
        sum += i * i
    return sqrt(sum)


path = ['/content/Neural-networks/Hamming Neural Network/examples of numbers/1.jpg',
        '/content/Neural-networks/Hamming Neural Network/examples of numbers/2.jpg',
        '/content/Neural-networks/Hamming Neural Network/examples of numbers/3.jpg',
        '/content/Neural-networks/Hamming Neural Network/examples of numbers/4.jpg',
        '/content/Neural-networks/Hamming Neural Network/examples of numbers/5.jpg',
        ]
x = []
print(os.path.basename(IMAGE_PATH))
for i in path:
    x.append(convertImageToBinary(i))
y = convertImageToBinary(IMAGE_PATH)
entr = y
k = len(x)
# Количество пикселей
a = 40
b = 40
entr = y
q = change(y, a, b)
plt.matshow(q)
plt.colorbar()

m = len(x[0])
w = [[(x[i][j]) / 2 for j in range(m)] for i in range(k)]  # Матрица весовых коэффициентов
T = m / 2  # параметр активационной функции
e = round(1 / len(x), 1)
E = [[0 for j in range(k)] for i in range(k)]  # Задаются значения синапсов обратных связей нейронов второго слоя в виде элементов квадратной матрицы размера K x K:
Emax = 0.000001  # максимально допустимое значение нормы разности выходных векторов на двух последовательных итерациях
U = 1 / Emax
for i in range(k):
    for j in range(k):
        if j == i:
            E[i][j] = 1.0
        else:
            E[i][j] = -e
s = [product(w, y, T)]
p = action(s[0], U, Emax)
y = [p]
i = 0
j = []
p = [0 for j in range(len(s[0]))]
while norm(y[i], p) >= Emax:
    s.append([0 for j in range(len(s[0]))])
    for j in range(len(s[0])):
        s[i + 1][j] = y[i][j] - e * mysum(y[i], j)
    y.append((action(s[i + 1], U, Emax)))
    i += 1
    p = y[i - 1]
print('Таблица выходных векторов:')
show(y)
print('Последний выходной вектор: ', *y[len(y) - 1])
j = []
i = 0
result_index = y[len(y) - 1].index(max(y[len(y) - 1])) + 1
if max(y[len(y) - 1]) == 0:
    print("Сеть Хэмминга не может отдать предпочтение между классами",
          "\nВ условиях малого количества входных характеристик следует сделать вывод, скорее, о том, что сеть вовсе не смогла классифицировать образ, чем о том, что она в равной степени отнесла его к вышеперечисленным классам")
    plt.show()
    exit()
else:
    q = change(x[result_index - 1], a, b)
    print('Положительное (наибольшее) выходное значение', result_index,
          '- го нейрона указывает на то, что зашумленный входной образ следует отнести к', result_index, '- му классу')
    plt.matshow(q)
    plt.colorbar()
    plt.show()

!python '/content/Neural-networks/Hopfield Neural Network/Hopfield.py'

from pylab import *

def change(v, a, b):
    t = [[0 for j in range(a)] for i in range(b)]
    k = 0
    j = 0
    while k < b:
        i = 0
        while i < a:
            t[k][i] = v[j]
            j += 1
            i += 1
        k += 1
    return t

def hamming(a, b):
    i = 0
    r = 0
    while i < len(a):
        if a[i] != b[i]:
            r += 1
        i += 1
    return r

def product(w, y):
    z = []
    for i in range(len(w)):
        x = 0
        for j in range(len(y)):
            x = x + w[i][j]*y[j]
        if x >= 0:
            x = 1
        else:
            x = -1
        z.append(x)
    return z

# x = [[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]]
# x = [[ -1, -1, 1, -1],[ 1, -1, 1, -1],[ -1, 1, -1, -1]]
# x = [[-1,-1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1],[1,-1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1],[1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1]]
# x = [[-1,-1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1],[1,-1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1]]
# m = int(input('Введите количество образцов: '))
# a = int(input('Введите ширину образца: '))
# b = int(input('Введите длину образца: '))
m = 2
a = 4
b = 5
f = open('/content/Neural-networks/Hopfield Neural Network/example.txt')
t = []
for i in f:
    t.append(i.split(','))
    for k in range(len(t)):
        for j in range(len(t[k])):
            t[k][j] = int(t[k][j])
x = []
h = m
while h > 0:
    x.append(t[h])
    h -= 1
f.close()
n = len(x[0])
y = t.pop()
w = [[0 for j in range(n)] for i in range(n)]
for i in range(n):
    for j in range(n):
        c = 0
        if i != j:
            for k in range(m):
                c = c + x[k][j]*x[k][i]
        w[i][j] = c
# y = [int(i) for i in input("Input y: ").split(' ')]
q = change(y, a, b)
plt.matshow(q)
plt.colorbar()
h = 0
while h < 5:
    z = product(w, y)
    r = hamming(z, y)
    h += 1
    if r == 0:
        z = change(z, a, b)
        print(z)
        plt.matshow(z)
        plt.colorbar()
        plt.show()
        exit()
    else:
        y = z
# 1,1,1,-1,-1,-1,1,1,1
# palka -1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1
# v = -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 1
# newv v = -1 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 -1
# print(change(v, 4,5))

# 1 1 1 1 -1 -1 -1 1 1 1 1 1 -1 -1 -1 1 -1 -1 1 1 цикл бесконечный
# -1 -1 -1 1 -1 -1 -1 1 1 1 1 1 -1 -1 -1 1 -1 -1 -1 1 ещё один

from pylab import *

def change(v, a, b):
    """
    Transform a vector into a matrix of specified dimensions.

    Args:
        v (list): The input vector to be transformed.
        a (int): The number of columns in the resulting matrix.
        b (int): The number of rows in the resulting matrix.

    Returns:
        list of lists: The transformed matrix.
    """
    t = [[0 for j in range(a)] for i in range(b)]
    k = 0
    j = 0
    while k < b:
        i = 0
        while i < a:
            t[k][i] = v[j]
            j += 1
            i += 1
        k += 1
    return t

def hamming(a, b):
    """
    Calculate the Hamming distance between two binary vectors.

    Args:
        a (list): The first binary vector.
        b (list): The second binary vector.

    Returns:
        int: The Hamming distance between the two vectors.
    """
    i = 0
    r = 0
    while i < len(a):
        if a[i] != b[i]:
            r += 1
        i += 1
    return r

def product(w, y):
    """
    Perform the dot product of a weight matrix and an input vector.

    Args:
        w (list of lists): The weight matrix.
        y (list): The input vector.

    Returns:
        list: The resulting vector after the dot product.
    """
    z = []
    for i in range(len(w)):
        x = 0
        for j in range(len(y)):
            x = x + w[i][j] * y[j]
        if x >= 0:
            x = 1
        else:
            x = -1
        z.append(x)
    return z

# Define the number of example images (m), width of each image (a), and length of each image (b).
m = 2
a = 4
b = 5

# Open a text file containing example binary vectors.
f = open('/content/Neural-networks/Hopfield Neural Network/example.txt')
t = []

# Read and parse the binary vectors from the file.
for i in f:
    t.append(i.split(','))
    for k in range(len(t)):
        for j in range(len(t[k])):
            t[k][j] = int(t[k][j])

x = []
h = m

# Retrieve example vectors from the parsed data.
while h > 0:
    x.append(t[h])
    h -= 1

f.close()
n = len(x[0])

# Retrieve the target binary vector (y).
y = t.pop()

# Initialize the weight matrix (w) with zeros.
w = [[0 for j in range(n)] for i in range(n)]

# Calculate the weight matrix using Hebb's rule.
for i in range(n):
    for j in range(n):
        c = 0
        if i != j:
            for k in range(m):
                c = c + x[k][j] * x[k][i]
        w[i][j] = c

# Initialize the input vector (y).
# y = [int(i) for i in input("Input y: ").split(' ')]

q = change(y, a, b)

# Display the initial input vector as a matrix.
plt.matshow(q)
plt.colorbar()

h = 0

# Iterate until convergence or a predefined number of iterations.
while h < 5:
    z = product(w, y)
    r = hamming(z, y)
    h += 1
    if r == 0:
        z = change(z, a, b)
        print(z)

        # Display the converged output vector as a matrix.
        plt.matshow(z)
        plt.colorbar()
        plt.show()
        exit()
    else:
        y = z